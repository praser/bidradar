name: Release

on:
  push:
    branches: [main]

# Prevent release commits from re-triggering the pipeline.
# The "chore(release): v*" commit pushed by the release job uses GITHUB_TOKEN,
# which does not trigger workflows by default. This concurrency group is a
# safety net in case a PAT is used instead.
concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  id-token: write

jobs:
  # ---------------------------------------------------------------------------
  # 1. Determine version bump from conventional commits
  # ---------------------------------------------------------------------------
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
      skip: ${{ steps.bump.outputs.skip }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'

      - name: Determine semver bump from conventional commits
        id: bump
        run: |
          # Skip if the triggering commit is a release commit (prevents loops)
          HEAD_MSG=$(git log -1 --pretty=format:"%s")
          if echo "$HEAD_MSG" | grep -qE "^chore\(release\): v"; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Head commit is a release commit — skipping"
            exit 0
          fi

          # Dry-run: get the next version without writing files
          VERSION=$(node scripts/bump-version.mjs --dry 2>/dev/null || true)
          if [ -z "$VERSION" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Could not determine version — skipping"
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "new_version=$VERSION" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # 2. Static checks + unit tests
  # ---------------------------------------------------------------------------
  checks:
    name: Static Checks & Tests
    runs-on: ubuntu-latest
    needs: version
    if: needs.version.outputs.skip != 'true'
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - run: pnpm build

      - run: pnpm typecheck

      - run: pnpm test --passWithNoTests

  # ---------------------------------------------------------------------------
  # 3. Deploy to staging
  # ---------------------------------------------------------------------------
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [version, checks]
    if: needs.version.outputs.skip != 'true'
    environment: staging
    outputs:
      staging_api_url: ${{ steps.sst-outputs.outputs.staging_api_url }}
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - run: pnpm build

      - uses: aws-actions/configure-aws-credentials@v4
        if: ${{ !env.ACT }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy with SST
        run: npx sst deploy --stage staging

      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: pnpm db:migrate

      - name: Read SST outputs
        id: sst-outputs
        run: |
          STAGING_URL=$(aws ssm get-parameter \
            --name /bidradar/staging/api-url \
            --query 'Parameter.Value' --output text)

          if [ -z "$STAGING_URL" ] || [ "$STAGING_URL" = "None" ]; then
            echo "::error::Could not determine staging API URL from SSM"
            exit 1
          fi

          echo "staging_api_url=$STAGING_URL" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # 4. E2E tests against staging
  # ---------------------------------------------------------------------------
  e2e-staging:
    name: E2E Tests (Staging)
    runs-on: ubuntu-latest
    needs: [version, deploy-staging]
    if: needs.version.outputs.skip != 'true'
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - run: pnpm build

      - name: Run E2E tests against staging
        env:
          DEV_API_URL: ${{ needs.deploy-staging.outputs.staging_api_url }}
        run: pnpm test:e2e:live

  # ---------------------------------------------------------------------------
  # 5. Deploy to prod
  # ---------------------------------------------------------------------------
  deploy-prod:
    name: Deploy to Prod
    runs-on: ubuntu-latest
    needs: [version, e2e-staging]
    if: needs.version.outputs.skip != 'true'
    environment: prod
    outputs:
      prod_api_url: ${{ steps.sst-outputs.outputs.prod_api_url }}
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - run: pnpm build

      - uses: aws-actions/configure-aws-credentials@v4
        if: ${{ !env.ACT }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy with SST
        run: npx sst deploy --stage prod

      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: pnpm db:migrate

      - name: Read SST outputs
        id: sst-outputs
        run: |
          PROD_URL=$(aws ssm get-parameter \
            --name /bidradar/prod/api-url \
            --query 'Parameter.Value' --output text)

          if [ -z "$PROD_URL" ] || [ "$PROD_URL" = "None" ]; then
            echo "::error::Could not determine prod API URL from SSM"
            exit 1
          fi

          echo "prod_api_url=$PROD_URL" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # 6. Release — tag, CLI, Homebrew
  # ---------------------------------------------------------------------------
  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [version, deploy-prod]
    if: needs.version.outputs.skip != 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git auth (act only)
        if: ${{ env.ACT }}
        run: |
          REPO_URL=$(git remote get-url origin | sed 's|git@github.com:|https://github.com/|' | sed 's|\.git$||')
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@${REPO_URL#https://}.git"

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      # --- Bump versions in all package.json files ---
      - name: Bump versions
        run: node scripts/bump-version.mjs

      # --- Generate / update CHANGELOG.md ---
      - name: Update CHANGELOG
        env:
          VERSION: ${{ needs.version.outputs.new_version }}
        run: node scripts/generate-changelog.mjs --version "$VERSION"

      # --- Commit version bumps + changelog ---
      - name: Commit version bump and changelog
        env:
          VERSION: ${{ needs.version.outputs.new_version }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json packages/*/package.json apps/*/package.json CHANGELOG.md
          git commit -m "chore(release): v${VERSION}"
          git push

      # --- Tag the release ---
      - name: Create tag
        env:
          VERSION: ${{ needs.version.outputs.new_version }}
        run: |
          git tag "v${VERSION}"
          git push origin "v${VERSION}"

      # --- Build all packages ---
      - run: pnpm build

      # --- Build CLI with prod URL baked in ---
      - name: Build CLI for release
        env:
          BIDRADAR_DEFAULT_API_URL: ${{ needs.deploy-prod.outputs.prod_api_url }}
        run: pnpm --filter @bidradar/cli build

      # --- Create CLI tarball ---
      - name: Create CLI tarball
        env:
          VERSION: ${{ needs.version.outputs.new_version }}
        run: |
          cd apps/cli
          tar -czf "../../bidradar-${VERSION}.tar.gz" dist package.json

      # --- Create GitHub Release ---
      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.version.outputs.new_version }}
        run: |
          # Extract just the latest changelog entry (from first ## to next ## or EOF)
          awk '/^## \[/{if(found) exit; found=1} found{print}' CHANGELOG.md > /tmp/release-notes.md

          gh release create "v${VERSION}" \
            --title "v${VERSION}" \
            --notes-file /tmp/release-notes.md \
            "bidradar-${VERSION}.tar.gz"

      # --- Update Homebrew formula ---
      - name: Update Homebrew formula
        env:
          GH_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          VERSION: ${{ needs.version.outputs.new_version }}
        run: |
          SHA256=$(sha256sum "bidradar-${VERSION}.tar.gz" | cut -d ' ' -f 1)
          URL="https://github.com/praser/bidradar/releases/download/v${VERSION}/bidradar-${VERSION}.tar.gz"

          git clone "https://x-access-token:${GH_TOKEN}@github.com/praser/homebrew-bidradar.git" /tmp/homebrew-bidradar

          sed -i "s|url \".*\"|url \"${URL}\"|" /tmp/homebrew-bidradar/Formula/bidradar.rb
          sed -i "s|sha256 \".*\"|sha256 \"${SHA256}\"|" /tmp/homebrew-bidradar/Formula/bidradar.rb

          cd /tmp/homebrew-bidradar
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Formula/bidradar.rb
          git commit -m "Update bidradar to ${VERSION}"
          git push

  # ---------------------------------------------------------------------------
  # 7. On failure — create GitHub issue
  # ---------------------------------------------------------------------------
  on-failure:
    name: Report Failure
    runs-on: ubuntu-latest
    needs: [version, checks, deploy-staging, e2e-staging, deploy-prod, release]
    if: failure() && needs.version.outputs.skip != 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Determine failed step
        id: failed
        run: |
          if [ "${{ needs.checks.result }}" = "failure" ]; then
            echo "step=Static Checks & Tests" >> "$GITHUB_OUTPUT"
          elif [ "${{ needs.deploy-staging.result }}" = "failure" ]; then
            echo "step=Deploy to Staging" >> "$GITHUB_OUTPUT"
          elif [ "${{ needs.e2e-staging.result }}" = "failure" ]; then
            echo "step=E2E Tests (Staging)" >> "$GITHUB_OUTPUT"
          elif [ "${{ needs.deploy-prod.result }}" = "failure" ]; then
            echo "step=Deploy to Prod" >> "$GITHUB_OUTPUT"
          elif [ "${{ needs.release.result }}" = "failure" ]; then
            echo "step=Release" >> "$GITHUB_OUTPUT"
          else
            echo "step=Unknown" >> "$GITHUB_OUTPUT"
          fi

      - name: Create failure issue
        env:
          GH_TOKEN: ${{ github.token }}
          FAILED_STEP: ${{ steps.failed.outputs.step }}
          VERSION: ${{ needs.version.outputs.new_version }}
        run: |
          BODY="## Release Pipeline Failure

          | Field | Value |
          |-------|-------|
          | **Failed Step** | ${FAILED_STEP} |
          | **Target Version** | v${VERSION} |
          | **Commit SHA** | ${{ github.sha }} |
          | **Workflow Run** | ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }} |
          | **Triggered By** | ${{ github.actor }} |

          ### What happened

          The automated release pipeline failed during the **${FAILED_STEP}** step.

          ### Next steps

          1. Click the workflow run link above to inspect the error logs
          2. Fix the underlying issue
          3. Push to main to trigger a new release attempt"

          gh issue create \
            --title "Release v${VERSION} failed at: ${FAILED_STEP}" \
            --label "bug,release" \
            --body "$BODY"
